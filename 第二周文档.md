

# 文档

## 一、问题描述

本周主要完成一个堆栈和队列。主要功能包括栈的初始化、入栈、出栈、获取长度、清空。队列与栈类似，主要是出入的方式不同。



## 二、思路分析&代码实现

### 1、堆栈

首先定义一个结构体并将其初始化，为top申请动态空间

	top = (LinkStack)malloc(sizeof(SNode));//为top申请动态空间
	top->next = NULL;//申请成功后，将top的下一个空间为空NIULL



然后定义一个指针p并为其申请动态空间，将数据输入并将每一个节点连接

	for (i; i < n; i++) {
		p = (SNode*)malloc(sizeof(SNode));//为p申请动态空间
		cin >> temp;//将要输入的数据赋值给temp
		p->data = temp;
		p->next = top->next;//将此时的top的地址空间传给p
		top->next = p;//将上面开辟的空间传给top
	}



初始化完成后，实现入栈和出栈的功能。由定义可知，栈只能在最后一个数据的基础上再添加数据或者删除最后一个数据，具体见注释

	top->next = p->next;//将此时的top的地址传给p
	d = p->data;//将要删除的数据交给d存下来
	cout << d << "已经出栈" << endl;
	free(p);//将top在上面传给p的空间释放



然后显示栈的长度，只要将栈遍历一遍，输出栈的数据个数即可

	p = top->next;//将栈顶（top）的位置的参数传给p
	if (top->next == NULL) {
		cout << "链表为空！" << endl;
		return 0;
	}
	cout << "链栈的数据为：" << endl;
	while (p != NULL) {
		temp = p->data;//将此时的p对应的数据赋值给temp便于输出
		cout << temp << endl;
		p = p->next;//位置参数将依次由while循环向下传导
	}



### 2、队列

队列与栈类似，区别在出入的方式不同，队列只能从队尾进入，从对头删除。因此初始化方式不同。具体见注释

    LQueue Q;//定义变量Q
    Qnode p;
    Q.front = Q.rear = (QueuePtr)malloc(sizeof(Qnode));//生成表头结点
    Q.front->next = NULL;//表头结点的next为空指针
    return Q;//返回Q的值

    Qnode* p;//说明变量p
    int n, i;
    Eletype e;
    cout << "请输入你要输入数据的个数：" << endl;
    
    //识别非法输入
    cin >> n;
    while (cin.fail())
    {
        cin.clear();
        cin.ignore();
        cout << "输入错误，请重新输入" << endl;
        cin >> n;
        system("pause");
        system("cls");
    
    }
    
    system("cls");
    cout << "请输入数据：" << endl;
    for (i = 0;i < n;i++)
    {
        p = (Qnode*)malloc(sizeof(Qnode));//生成新元素结点
    
        cin >> e;
    
        Q->rear->next = p;
        p->date = e;//装入元素e
        p->next = NULL;//为队尾结点
        Q->rear = p;//修改尾指针
    }

入队，出队如下

    Eletype n;
    QueuePtr p, q;
    p = Q->rear;
    cout << "请输入您想输入的数据：" << endl;
    cin >> n;
    q = (Qnode*)malloc(sizeof(Qnode));
    q->date = n;
    p->next = q;
    q->next = NULL;
    Q->rear = q;

    QueuePtr p;
    Eletype n;
    if (Q->front != Q->rear)
    {
        p = Q->front->next;
        Q->front->next = p->next;
        n = p->date;
        if (Q->rear == p)
        {
            Q->rear = Q->front;
        }
        free(p);



## 三、测试结果

### 1、队列

![image-20220327203013162](D:\QJ\week2\文档图片\第二周周记.md)

![image-20220327203117113](D:\QJ\week2\文档图片\image-20220327203117113.png)

![image-20220327203149482](D:\QJ\week2\文档图片\image-20220327203149482.png)

![image-20220327203212399](D:\QJ\week2\文档图片\image-20220327203212399.png)

![image-20220327203235256](D:\QJ\week2\文档图片\image-20220327203235256.png)

![image-20220327203301951](D:\QJ\week2\文档图片\image-20220327203301951.png)

### 2、栈

![image-20220327203359969](D:\QJ\week2\文档图片\image-20220327203359969.png)

![image-20220327203423235](D:\QJ\week2\文档图片\image-20220327203423235.png)

![image-20220327203453057](D:\QJ\week2\文档图片\image-20220327203453057.png)

![image-20220327203516216](D:\QJ\week2\文档图片\image-20220327203516216.png)

![image-20220327203534438](D:\QJ\week2\文档图片\image-20220327203534438.png)